
### レーベンシュタイン距離

- `概説`
  - 挿入、置換、削除にそれぞれ重みを持たせて、「文字列A」から「文字列B」に変換する時の最小コストを出すもの
  - 例えば置換のコストを1、挿入と削除のコストを2とした場合、「abcde」と「abde」だったら最小コストは2になる（「c」を削除して「abde」にするだけなので）
  - そのコストは任意に設定してOK。作りたいシステム的な意味で重みをなんとなく設定すればいい
- `コード進行類似検索に使えそうか` = NG
  - コード進行は単純な文字列の近さだけじゃないから単純には行かなさそう
    - ディグリー化した時の文字列の近さなら使えそう
  - でも1曲まるまるだと似ている曲でも1セクション無いだけで違う判定されそう
  - でもそもそも1万曲あったら1曲のコード進行に対して1万回レーベンシュタイン距離計算するのは無理がありそう

### 最近傍探索（を勝手に解釈したやつ）

- `概説`
  - データを独自基準でベクトル化する
  - そのベクトルを元に、ベクトル空間上での距離を計算する
    - 例えばXが「機能（TSD等）での近似度」、Yが「テンションの多さ」、Zが「ディグリーでの類似度」だとして、それの距離が近ければ似てるとする等
    - 各XYZの値の出し方はどんなアルゴリズムでもいい（AI的なやつでも、単純な計算式でも）
- `コード進行類似検索に使えそうか`
  - 2次元にすればPostgreSQLの二次元幾何データ型用のGiSTインデックスでそれなりに高速に使えるのかも
    - 例: `SELECT * FROM places ORDER BY location <-> point '(101,456)' LIMIT 10;`
  - [pgvector](https://github.com/pgvector/pgvector)を使えば3次元でもいけそう
    - 例: `SELECT * FROM places ORDER BY location <-> point '(101,456,789)' LIMIT 10;`

### LLM

- なんかChatGPTっぽいもののコード進行版を作ればどうとでもなりそう

### n-gram

- 単純な文字列として扱えないので厳しそう。PostgreSQLでやるなら単純な文字列である必要があると思う

### 数小節単位でタグ付けをして、タグの被り度が高いほど類似度が高いとする

- 例えば王道進行とか、小室進行だとか、いくつそういうタグがかぶるかで類似度を出す
- 大量にタグを作る必要がある
