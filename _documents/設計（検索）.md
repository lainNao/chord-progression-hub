# 設計（検索）

## 機能

- デフォルト検索
  - コード進行に対してあいまい検索
- 詳細設定（githubの検索のようなイメージ）
  - 検索先
    - セクション名の指定
    - セクションをまたいでもよいか
  - 検索種類
    - 完全一致検索
    - あいまい検索（類似検索）

```UI
-------------------------------
| C-Em-Gm7-A            | 検索 | 
-------------------------------

[検索の詳細設定を開く]
（[全てのセクションに対して]、[完全一致&類似一致] ）
```

詳細設定ボタン押下で以下が右からスライドで開く。Elastic UI的なイメージに近い

```UI
<コード進行をどのセクションから検索したいか>
  ✔ 全てのセクションに対して （デフォルト）
  ◯ 特定セクションのみ
    ◯ セクション名: [  ]
    ◯ 指定のコード進行がセクションをまたいでも検索に引っかかるようにする (?)

<コード進行がどのくらい一致したら検索に引っかかるようにしたいか>
  ✔ 完全一致＆類似一致 （デフォルト）
  ◯ 完全一致のみ

<曲の特徴>
  ジャンル [  ]
  国 [  ]
  BPM [  ]


    
[ 検索の詳細設定をデフォルトに戻す ]

```

## DB

- 

## DB（パフォーマンス）

- postgresql
  - 実行時間
    - 10万曲、1曲あたり200文字のデータベースで、「C F G C」のような検索を行う場合、上記の要因によって実行時間は変動しますが、適切なインデックスが貼られていれば、数ミリ秒〜数十ミリ秒のオーダーでの応答が期待されます（ただし、これはあくまで大まかな目安です）。実際の実行時間を知りたい場合、テストデータを用いてベンチマークテストを行うことが最も確実です。
  - インデックスの利用:
    - LIKE や ILIKE のクエリに対しては、btree インデックスも利用される場合がありますが、前方一致のみです。
    - pg_trgm モジュールを使い、trigramインデックスを使うことで部分一致検索も高速化できます。
      -sql
        `CREATE EXTENSION pg_trgm;`、`CREATE INDEX idx_column_trgm ON your_table USING gin(column_name gin_trgm_ops);`
  - Text Searchの利用:
    - PostgreSQLの組み込みのフルテキスト検索機能を利用することで、高速な検索を行うことができます。tsvector と tsquery を利用して検索を行い、それに関連するインデックスを作成することで、検索速度を向上させます。
  - 設定の最適化:
    - postgresql.conf の設定値をチューニングして、パフォーマンスを向上させることができます。
      - shared_buffers: 使用するメモリ量に応じて調整します。
      - effective_cache_size: システムの全体のキャッシュサイズを反映させるように設定します。
      - work_mem: ソートやハッシュテーブル操作の際のメモリの使用量を調整します。大きくするとパフォーマンスは向上しますが、多数の接続がある場合には注意が必要です。
      - maintenance_work_mem: VACUUMやインデックスの作成時のメモリ使用量を調整します。
  - 分析の実行:
    - ANALYZE を実行して、クエリプランナが最適なクエリを選択できるようにします。
  - 監視ツールの導入:
    - pg_stat_statements などの拡張モジュールを使って、実行されるクエリのパフォーマンスを監視し、ボトルネックとなっている部分を特定します。
  - 物理的なストレージの最適化:
    - SSDの使用や、I/Oの高速化を図るためのRAID構成など、物理的なストレージの最適化もパフォーマンスに影響します。

## バックエンド

- a

## フロント

- UI的には「この曲のAメロと似ているコード進行がある曲」的なのを下部に置くとかね。出すのは「アーティスト名/曲タイトル/セクション/コード進行のみだし」等。

## 類似検索アルゴリズムの検討

- 結論：最終的には単に文字列検索に頼ったほうが良さそう
  - そもそも検索なのでSQL又はそれに準ずるものでDBに問い合わせる必要があり、基本的にはあまりコードを介してはならないはずなので、高度な機械学習による類似度判定は使えない
  - ベクトルデータにすれば類似度判定がDBに閉じるけれども、そういうのは画像とか曖昧な文章とかに向いてるだけで、コード進行をベクトルデータにしても精度がよくない（いい精度を出すには独自のchord2vecを作る必要があり、面倒。多分無理）。そもそもchord2vecを作るにしても内部実装は重み付けとかで頑張る必要がありそうで、そういう頑張りをするなら結局DBに非正規化した文字列カラムをいくつか作ってそれらから検索しても同じような頑張りなのではと思える
- ということで文字列検索前提で考えてみる
  - 1テーブルに非正規化したカラムをいくつか作る場合
    - `chords`テーブル
      - 基本カラム
        - id ...id
        - music_id ...曲名ID
        - raw ...一応保存しておく、生のコード進行文字列カラム
    - `chords_search`
      - 基本カラム
        - id ...id
        - music_id ...曲名ID
        - chords_id ...chordsテーブルのid
      - 以下検索用カラム（meta_infoとかは基本は省略し、全コードを「|」区切りで保存する）
        - normalized ...rawを、#とかbとかをどっちかに統一したカラム
        - tensionless ...normalizedから、テンションコードを抜いたもの
        - functional ...tensionlessを、TSD等の機能に変換したもの
        - degree ...functionalを、ディグリーに変換したもの
  - 仮にAメロに対してのみ検索をかけるのはどうしよう。さすがにAメロオンリーカラムとか作るのも嫌なので、正規表現で検索をかけることになるかな？postgresqlでもできそう。諦める？
