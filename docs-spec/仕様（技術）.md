# 目次

- [技術選定留意](#技術選定留意)
- [技術方針](#技術方針)
- 技術選定
  - [セキュリティ技術](#セキュリティ技術)
  - [PJ管理技術](#pj管理技術)
  - [DB技術](#db技術)
  - [インフラ技術](#インフラ技術)
  - [バックエンド技術](#バックエンド技術)
  - [フロントエンド技術](#フロントエンド技術)
  - [QA技術](#qa技術)
  - [監視技術](#監視技術)

## 技術選定留意

- [ ] 開発環境では代替のモック環境をdocker等で用意して使う(spec-20231231134106)
  - 例えばDBはNeonを使うが、開発環境ではdockerでPostgreSQLサーバを立てて使いたい

## 技術方針

- [ ] 12factorを守りたいな(spec-20240101190532)
  - <https://12factor.net/>

## PJ管理技術

- [x] `Git`　・・・GitHub(spec-20231220223235)
- 推奨ツールは以下
  - direnv

## DB技術

- [ ] `DB`　・・・Neon(spec-20231227205703)
  - CloudSQL for MySQL　・・・やっぱ高い印象があり…Neonの方が安いっぽいのでNeon
    - 一回「フルテーブルスキャンするからPlanetScaleはやめ」となった
    - ただ、やっぱfor CloudSQLは高いっぽいいので、Neonの方にしてみる
      - ちなみにMySQLなのは、スペック(<https://cloud.google.com/sql/docs/feature_support?hl=ja>)を見てチェックが付いてるのが一番多かったところが理由。あと少し早いっぽい知らんけど
  - PlanetScale　・・・安牌っぽい。ChatGPTに見積もってもらったらCloudSQLよりも結構安かった
    - でもTursoと分担してもよいのかも
    - あーでも、like検索でフルスキャンするつもりなら向いてないっぽいかも…cloud sqlとかにしておくかな…？
      - 別途、ちゃんとインデックス効かせるようにしたいけど
        - そこが無理だったのでやっぱやめた…
  - Neon　・・・トランザクションがwebsocketで面倒かも？あともうGCPでまとめたいのであえて外部のを使ったりしない
    - と思ったけど料金の理由でやっぱ使ってみる
  - D1　・・・maximum database sizeが2GBと小さい
  - Turso　・・・sqliteなので特大データで怖いかも。fts5は使いたかったけど、
    - docker使わないでローカル開発できるかもなのは偉くはある
    - あとPlanetScaleのように行の読み取り数とかも課金対象っぽいな。これは今回はきついかも
  - PlanetScale　・・・
    - FULLTEXT タイプのインデックス貼ればngramできるっぽいしOK？うーんでもngramでよいものか…
      - これが試して微妙だったらTursoでfts5（tokenize=ascii）を使うかも。試してみてから決めたい
    - コレーションに注意
    - 外部キーは今ベータで対応してるっぽい
  - Digital Ocean　・・・VPS感
  - ScaleGrid　・・・どうなんだろう？
  - HarperDB　・・・どうなんだろう？
- [ ] マイグレーションツール　・・・flyway(spec-20231227222104)
  - Neon使ってるとそうなりそうなので <https://neon.tech/docs/guides/flyway>
  - Prismaでもできるだろうけど、、、なんでもいいので
- [ ] `DB管理`　・・・bytebase？(spec-20231220223328)
  - 面白そうなので。どうだろう？
- `テーブル定義`
  - [ ] `DBのエンティティ`フォルダにあるエンティティがテーブルのイメージで、それをを元にテーブルを作成(spec-20231221010009)
- `パフォーマンス`
  - [ ] 10万件でのlike検索が1秒台で結果返ってきたので、もうとりあえずしばらくはlike検索でいいはず(spec-20231221010205)
    - かなりの期間は持つはず。色々調べたけど結局なんかNeo4jまで話が行ってるくらい検証に時間がかかるっぽい話題だとなったし、ここらへんは一個コンポーネントとしてまとめとけばいつでもリファクタできるし、一種のパフォーマンスチューニングでしかないし、後でにしないともう無理かと思った。そもそもサービスが年単位で持つかも一応まだ不明だし
  - [ ] でも「セクションのはじめにこのコード進行から始まる」系の検索ならばインデックス効くlike検索ができるな(spec-20231227173017)
  - [ ]  仮にlike検索ではどうともならなくなってきた時、コストかけてどうにか考える(spec-20231221010207)
    - 最悪postgresの拡張機能を自作するなど…
    - ngramだと`like '%...%'`でもインデックス効かせられるけど、精度が完璧じゃないっぽい（ただ特にコード進行文字列を別のものに変換してからDBに入れる必要も基本は無いかも）
    - いや、それだとコードを厳密に検索できないので、もはや曲に含まれるコード毎に自分でハッシュテーブルを作ってインデックスを管理しちゃってもいいのかも…？例えば以下のようなデータ構造で(spec-20231227150539)

      ```json
      {
        "コード": {
          "曲ID": true,
          ...,
        },
        ...,
      }
      ```

    - これがあれば、例えば「C-F-G』と検索されたらまず「C、F、G」の曲IDどれも持ってる曲を出して（ここはアプリケーション側でやることになっちゃうかも）、それらの曲からそれらがその通り連続してる曲をngramで検索するとかしたらまだDBの負荷は減る…？うーん
  - うーんNoSQL系でなんか適したの無いかな…？jsonbとかでも何かデータを工夫したらいい感じになる方法とか、、
    - neo4jとか、あとは地味に諦めたけどElasticsearchとかは無難にできるのかも…。でもelasticsearchだと単なる文字としての検索になってしまって面倒だから本質的にはNeo4jのようなもののほうがよいのかも…？
      - neo4jだと以下のように鳴るっぽいな…？簡単な例だと。（ただ以下の例だとコードのノードが大量にできるので、コードは共通のノードとして使い回すようにするのも検討できるならしたいな。そっちのほうがクエリは複雑になるっぽいけども…？）

      ```js
      // まず https://hub.docker.com/_/neo4j を参考にneo4j起動
      // http://localhost:7474にアクセスして、neo4j/neo4jでログイン
      // パスワードを適当に変えてダッシュボードにアクセスして以下を発行

      // 曲A「C-F-G-C」を登録
      CREATE (a:Song {title: 'Song A'})
      CREATE (c1:Chord {name: 'C'})
      CREATE (f:Chord {name: 'F'})
      CREATE (g1:Chord {name: 'G'})
      CREATE (c2:Chord {name: 'C'})
      CREATE (a)-[:PROGRESSION]->(c1)-[:NEXT {song: 'Song A'}]->(f)-[:NEXT {song: 'Song A'}]->(g1)-[:NEXT {song: 'Song A'}]->(c2)

      // 曲B「Am-Dm-G-C」を登録
      CREATE (b:Song {title: 'Song B'})
      CREATE (am:Chord {name: 'Am'})
      CREATE (dm:Chord {name: 'Dm'})
      CREATE (g2:Chord {name: 'G'})
      CREATE (c3:Chord {name: 'C'})
      CREATE (b)-[:PROGRESSION]->(am)-[:NEXT {song: 'Song B'}]->(dm)-[:NEXT {song: 'Song B'}]->(g2)-[:NEXT {song: 'Song B'}]->(c3)

      // 「G-C」というコードの流れがある曲一覧を検索
      MATCH (song:Song)-[:PROGRESSION]->(:Chord)-[:NEXT*]->(g:Chord {name: 'G'})-[:NEXT]->(c:Chord {name: 'C'})
      RETURN DISTINCT song.title
      ```

      - ただこの場合、やっぱりディグリーでの検索はワークアラウンドが必要。まあそこはそうか…。でもLookupChordProgressionBySectionを置き換えられるならそれはそれだけでよいなかもね。functionalはできるし、normalizedはたぶんそもそも不要だし（これ、別に普通のRDBでもngram使うならそもそも不要かもね）、tensionlessは同じノードに組み込めるし。あとはどっちがパフォーマンスがいいか見てみたいな（料金も最終的には…）。ここは面倒だ…。でも精度的にはneo4jのほうがまだありかな？（RDBのngramだとテンションありのカラムに対する検索精度が落ちるのはありそう。例えば2gramにしちゃった場合、「G7」と検索したら「G7(13)」とかもかかってしまうのかも？「G7 」のように半角スペースかハイフン混ぜるようにしたらどうだろう…）。そういう意味で精度の意味で面倒なのはngramの方かな。となるとLookupChordProgressionBySectionはneo4j使ってみるようにしてみるかな…？なかなか大掛かりだけど…あとはパフォーマンスと料金を見てみたいところ…
      - postgresqlのカスタム辞書はなんか今回の用途では完璧に適しているっぽくはなかった

- `検討したこと`
  - パフォーマンス周り
    - fts5　・・・うまくtokenizeしてくれなくて面倒だった。そもそも普通のlike検索がそれなりに早かったから一旦いいやとなった
    - pg_trgm　・・・trigramが合わないと思う
    - elasticsearch　・・・言うほど早くなかったのと、_analyzeした時に勝手に小文字化されて面倒だった。そもそも普通のlike検索がそれなりに早かったから一旦いいやとなった
  - 検索用の非正規化したデータを格納するテーブルをいくつか作り、そこに対して全文検索をかけるようにする →採用
  - ベクトル検索
    - そもそも検索なのでSQL又はそれに準ずるものでDBに問い合わせる必要があり、基本的にはあまりコードを介してはならないはずなので、高度な機械学習による類似度判定は使えない
      - ベクトルデータにすれば類似度判定がDBに閉じるけれども、そういうのは画像とか曖昧な文章とかに向いてるだけで、コード進行をベクトルデータにしても精度がよくない（いい精度を出すには独自のchord2vecを作る必要があり、面倒。多分無理）。そもそもchord2vecを作るにしても内部実装は重み付けとかで頑張る必要がありそうで、そういう頑張りをするなら結局DBに非正規化した文字列カラムをいくつか作ってそれらから検索しても同じような頑張りなのではと思える
  - `2222555511116666 みたいな長いコード進行も「2516」で検索引っかかるようにしたい件`
    - かといって4444444411116666のDBに入れるデータを「416」とかにしたら「1416」と検索しても引っかかっちゃうからそういうのは嫌だなどうすればいいか
    な
    - `結論:` いやこういうのはそもそも2516で登録すればいいのでは？
  - Q: 検索系テーブル、ハッシュテーブル的なNoSQLでは駄目なの？
    - A: 要件的に無理っぽい。工夫すればできるのかな…？

## 監視技術

- 正常系のログやメトリクスは、あまり料金かかるものはやらなくていい。かっこいいので知的好奇心は向かうかもしれないけど
- [ ] 異常系のエラーとかは収集する(spec-20231221011017)
  - [ ] 特に例えば`chord-progression-ast-parser`関連のエラーは、エラーとなった入力ももらってくる(spec-20231221011038)
    - 単なる「正常なバリデーションエラー」の場合は収集は不要

## フロントエンド技術

- [ ] カラーパレットはツールを使う(spec-20231221020049)
  - `候補`
    - <https://github.com/material-foundation/material-color-utilities>
- [ ] `コンポーネントライブラリ`　・・・chadcn/ui、tailwind(spec-20231220223357)
  - chadcn/uiにした理由
    - 大量テーマ切り替えが楽そう <https://ui.shadcn.com/themes>
    - フォームが多くならないはず
      - 仮にフォームが多くなる場合、フォーム系コンポーネントにはshadcn/uiだともしかしたら面倒になりそう
- [ ] `フォーム`　・・・？（Tally？）(spec-20231220223402)
  - できればreact-hook-formとかは面倒なので使いたくない。やってみて駄目なら使う
- [ ] `APIクライアント`　・・・不要？またはtRPC等(spec-20231220223340)
  - （Next.jsのappルーターだとたぶんRESTは出る幕無いので、たぶん簡単なやつでいい）
- [ ] `可変サイズ`　・・・htmlタグにfont-sizeを設定し、配下では絶対にrem指定をすることで対応。font-sizeだけど、これはrem全体に聞くはずなので、画像サイズとかにも有効にできるはず。ちなみにQaseはそんな感じで実装してるはず(spec-20231221004035)
- [ ] browserslist等工夫して、古いCSS対応も自動化したい(spec-20231221010458)
  - post cssとかも
  - できれば自動チェック
- [ ] `バンドルサイズ監視`　・・・?(spec-20231221004100)
- [ ] `Next.jsのルート可視化`　・・・NEXT.NAV(spec-20231220223411)

## QA技術

- `ステージング環境`
  - [ ] 任意のタイミングでステージング環境をデプロイ&アクセスできるようにする。(spec-20231229003839)
    - 料金的な都合上、プルリクごとの環境は作らない
    - terraform上は主にプロジェクトIDを切り替えることで本番、ステージングを切り替えたい。Neonのブランチとかは別途違うのを使う等考える
  - [ ] ステージング環境は、アクセスできるユーザーを絞る。(spec-20231229004102)
  - [ ] ステージングの時はconsole.logでその旨を表示する。(spec-20231229003840)
  - [ ] ステージング環境は、3日以上残ってる時は「料金かかってるけどまだいるの？一旦消さないでいいの？」と通知を送る等したい(spec-20231229004845)
- [ ] `packages-dev/commonTestCaseRunners`を使い、汎用的なテストケースを網羅させる。仕様として管理するまでもないが地味に重要なやつを逃さないようにしたい。(spec-20231221015337)
- [ ] `VRT`　・・・Chromatic（ただし料金的な意味で、導入はデグレを防ぎたくなってきた時期（完成が見えてから）でいい）(spec-20231220223404)
  - もしR2でreg-suit使えるならreg-suitでもいいかも
- [ ] `E2E`　・・・Playwright(spec-20231220223405)
  - axe-playwright
- [ ] `テストランナー` ・・・jest、storybook(spec-20231220223407)
  - @storybook/addon-interactions
- [ ] `リント`　・・・ESLint、Prettier、ls-lint、stylelint、etc(spec-20231220223408)
  - 以下候補
    - eslint-plugin-unicorn
    - eslint-plugin-react
    - eslint-plugin-react-hooks
    - eslint-plugin-jsx-a11y
    - eslint-plugin-import
    - eslint-plugin-storybook
    - eslint-plugin-jest
    - eslint-plugin-testing-library
    - typescript-eslint
    - @storybook/addon-a11y
    - `typescript-eslint`がeslintはフラットコンフィグをサポートしないとか言ってるらしいので注意しておく
- [ ] `~.◯◯.ts`などの〇〇の部分に入るやつはls-lintとかでリントかけよう。sつけ忘れや逆にsが多くなるとかで統制取れなくなるから(spec-20231221004150)
  - ls-lintでないやつでよいものがあるならそっちでもいい。eslintにもあったような

## バックエンド技術

- [ ] `サーバー`　・・・Remix(spec-20231220223334)
  - Next.js　・・・
    - キャッシュ機構、next/imageなど、Vercel使わないと少し面倒？
    - VercelはAWSに乗ってるので、それならAWS使いたい（というか高いイメージ）
    - 後、今回はシンプルなアプリケーションなので、そんな高機能でなくていい
      - SNSとかならNext.jsのがよかったかな
  - Remix　・・・
    - Cloudflare使うならRemixが良さそう。
      - 注意点としてworkersは1MBのリミットがあるっぽいのであまりバンドルサイズの大きいライブラリを使ってはいけない（間に合うのかな、）
      - 有料なら10MB
      - 小さくするのはCIとしてもコスパいいので、やってみたくはある
    - Next.jsはある程度使ったことある
    - ただ、Cloudflare workersをサイズなどの制限で使えないとなった場合、Next.jsにするはず
  - Qwik city　・・・
    - 安さを追求するならこういうパフォーマンスを意識したやつでもありではあるのかも知らんけど
- [ ] `ORM`　・・・Prisma、駄目ならDrizzle、駄目ならKysely(spec-20231220223338)
- [ ] `課金`　・・・？(spec-20231220223347)
- [ ] `ログイン`　・・・？（Clerk？next/auth？）(spec-20231220223350)
  - Clerkは無料枠が5000(?)で他のより何かが少ないっぽいので今回はスルー
  - Auth0はやったことあるし高いっぽいので今回はスルー
- [ ] `メール送信`　・・・AWS SES(spec-20231220223352)
  - 安いらしいので <https://zenn.dev/link/comments/fbe8e9be92ac10>
  - Resend　・・・SESに負けるっぽい？
  - SendGrid　・・・SESに負けるっぽい？
- [ ] `メール本文作成`　・・・react email（emailのhtmlをreactコンポーネントで作れるやつ）(spec-20231220223354)
- [ ] `i18n`　・・・？(spec-20231220223359)
  - なんか色々試されていた <https://twitter.com/d151005/status/1727190995299881006>
  - トップページだけはやっぱりSEO的な意味でサブパスでのルーティングにして国ごとに分けていいのかも…？
  - 全部サブドメインルーティングにするのはしなくていい気がする（手軽ならやっちゃっていいかもだけど）

## セキュリティ技術

- [ ] `DDoS対策`　・・・?(spec-20231220223430)
  - MPAなので、実質これがSPAのレートリミット対策と同じことになるはず。
  - なのでほぼレートリミット対策は不要かな？API作るならこういうので考える <https://zenn.dev/catnose99/articles/9183c86d3558e5>
- [ ] `シークレットの漏洩`　・・・?(spec-20231231222308)
  - なんのシークレットがどう漏洩したかのパターンによるな

## インフラ技術

- [x] Terraformのバージョンアップは、`terraform plan`して差分が無ければOKとしちゃう(spec-20240101192602)
- [ ] そういえば、REST APIも提供するとなるとサーバー2つ実装する？もしその場合、サブドメイン的なやつの技術を事前に小さく試したい(spec-20240101040455)
  - もしくはNext.jsのAPIルートとかで実装しちゃえば単一サーバーでいけるけども…？どっちがよいのか
    - RemixでもAPIルート的なのは可能 <https://remix.run/docs/en/main/guides/resource-routes#handling-different-request-methods>。apiフォルダ作ってやればいい
      - 運用の苦労が増えるから同じサーバーに置いちゃえ。Remixのリソースルートを使うことにする
- [ ] GCPの環境は新規でプロジェクト用のメールアドレスを作成し、それから構築する(spec-20231221014424)
  - そちらのほうが業務的な活動メールアドレスであるし、かつ無料枠が使えるかもなので。
- [ ] `ブルーグリーンデプロイとかの安全なデプロイをどうやるか`　・・・？(spec-20231220223912)
- [ ] `CI`　・・・GitHub Actions、Lefthook(spec-20231220223236)
- [ ] `CD`　・・・GitHub Actions、etc(spec-20231220223238)
- [ ] `IaC`　・・・Terraform(spec-20231220223239)
  - Pulumi　・・・好きだったけどNeonで使えない <https://github.com/pulumi/pulumi/issues/13699>
  - Terraform　・・・苦手だったけどNeonはこっちしか無理
- [ ] `CDN`　・・・Cloudflare(spec-20231220223240)
- [ ] `ドメイン取得`　・・・？(spec-20231220223242)
- [ ] `DNS`　・・・Cloudflare(spec-20231220223243)
- [ ] `ロードバランサー`　・・・?(spec-20231220223244)
- [ ] `ホスティング`　・・・Cloud Run(spec-20231220223245)
  - GAE　・・・VMベースというかちょっと時代が古いっぽい
    - あと、環境が制限されるので「うわーこれやるならCloud Runに乗り換えるしかないじゃん」が発生しそうなので。GAEはすっごいシンプルなウェブサイトに使うくらいな気がする
  - Vercel　・・・高いのでそれ使うならAWS使いたい
  - Cloudflare workers　・・・試した結果BFF的な簡易サーバーにしかならなさそうだし、なんだかんだwasm動かせなかった
- [ ] `メール`　・・・？(spec-20231220223250)
- [ ] `ログ`　・・・？(spec-20231220223252)
- [ ] `モニタリング`　・・・？(spec-20231220223253)
- [ ] `バックアップ`　・・・？(spec-20231220223255)
- [ ] `メッセージング`　・・・？(spec-20231220223256)
- [ ] `バッチ・ジョブ`　・・・？(spec-20231220223300)
- [ ] `アクセス解析`　・・・Google Analytics？(spec-20231220223304)
- [ ] `環境分離（本番、ステージング、開発）`　・・・Gitのブランチでdevelop、staging、productionを分ける（mainは不要）。stagingにプッシュされたらステージング環境にデプロイし、productionにプッシュされたら本番環境にデプロイする。でいいかな？(spec-20231220223306)
- データ
- [ ] `ストレージ`　・・・Cloudflare R2(spec-20231220223330)
  - 圧倒的に安いらしいので
- [ ] `セッション`　・・・Cloudflare KV? Upstash？(spec-20231220223331)
- [ ] `フォント`　・・・Cloudflare Fonts(spec-20231220223332)
